import React from 'react';import RootStore from '../../../store/RootStore/root-store';import {LoadingEnum, NewWalletType, SpendDataType, WalletModelType,} from '../../Type/models';export class WalletStoreService {    rootStore: typeof RootStore;    constructor(rootStore: typeof RootStore) {        this.rootStore = rootStore;    }    async addWallet(newWallet: NewWalletType): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching)        try {            await this.rootStore.WalletStore.addWallet(newWallet);            await this.rootStore.WalletStore.getWallets(newWallet.userId);            this.rootStore.Notification.setNotification('success', true);        } catch (e) {            this.rootStore.Notification.setNotification('error', true, e?.response?.data?.message);        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.initial)        }    }    async addSpending(data: SpendDataType) {        /*this.rootStore.Notification.setIsLoading(LoadingEnum.fetching)*/        try {            await this.rootStore.WalletStore.addSpending(data);            this.rootStore.Notification.setNotification('success', true);            return true        } catch (e) {            this.rootStore.Notification.setNotification('error', true, e?.response?.data?.message);        } finally {            /*	this.rootStore.Notification.setIsLoading(LoadingEnum.initial)*/        }    }    async removeWallet(userId: string, walletId: string): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching)        try {            await this.rootStore.WalletStore.removeWallet(userId, walletId);            await this.rootStore.WalletStore.getWallets(userId);            this.rootStore.WalletStore.clearChosenWallet()            this.rootStore.HistoryStore.clearSelectedWalletHistory()            this.rootStore.Notification.setNotification('success', true);        } catch (e) {            this.rootStore.Notification.setNotification('error', true, e?.response?.data?.message);        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.initial)        }    }    async updateWallet(walletId: string, wallet: WalletModelType, loadingOff?: boolean) {        !loadingOff && this.rootStore.Notification.setIsLoading(LoadingEnum.fetching)        try {            await this.rootStore.WalletStore.updateWallet(walletId, wallet);            await this.rootStore.WalletStore.getWallet(walletId);            this.rootStore.Notification.setNotification('success', true);            return true        } catch (e) {            this.rootStore.Notification.setNotification('error', true, e?.response?.data?.message);        } finally {            !loadingOff && this.rootStore.Notification.setIsLoading(LoadingEnum.initial)        }    }    async getWallets(userId: string): Promise<void> {        this.rootStore.Notification.setIsLoading(LoadingEnum.fetching);        try {            await this.rootStore.WalletStore.getWallets(userId);        } catch (e) {            this.rootStore.Notification.setNotification('error', true, e?.response?.data?.message);        } finally {            this.rootStore.Notification.setIsLoading(LoadingEnum.initial);        }    }}export default WalletStoreService;